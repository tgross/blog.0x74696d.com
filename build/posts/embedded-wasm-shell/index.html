<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
  <title>0x74696d | An Embedded WASM Shell</title>
  <meta name="author" content="map[]" />
  <meta name="description" content="T-Minus 15.193792102158E&#43;9 years until the universe closes!" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="alternate" type="application/rss+xml" href="/rss.xml" />
  
  <link rel="stylesheet" href="/css/base.css" type="text/css" media="all" />
  <link rel="stylesheet" href="/fonts/ss-social.css" type="text/css" />

  <link rel="stylesheet" href="/css/pygments.css" type="text/css" />
</head>

<body>
  <div class="header">
    <div class="container">
      <section class="name">
        <a href="/"><b>0x74696d</b></a>
      </section>

      <ul class="menu">
        <li><a href="/">Posts</a></li>
        <li><a href="https://github.com/tgross?tab=repositories">Projects</a></li>
        <li><a href="/community/">Community</a></li>
        
      </ul>

    </div>
  </div>

<section class="container content">
  <h1>An Embedded WASM Shell</h1>
  <section class="byline">September 30, 2021</section>
  <p>If I go back far enough, it's clear my professional career in tech
started with the realization that AutoCAD's command line interface was
in fact a <em>shell</em>. It didn't just accept instructions, but you could
write little programs in this &quot;weird language&quot; called Lisp and it
would make calculations based on your drawing or even make changes to
the drawing<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>. I started with automating repetitive work, and then
one day a forward-thinking architect I worked with asked if I could
write a program that would make accurate construction bid
estimates. The first project built came within 5% of the software
estimated budget, and it's been a roughly 20 year trip from there to
writing blog posts about WASM for you today.</p>
<p>But the important part of this trip down memory lane is the notion
that you can have software that includes a constrained embedded
programming environment, and the power this provides a skilled user to
fit the software to their purpose. A former colleague <a href="https://twitter.com/numbsafari">Sam
Wilson</a> gave a great talk at the
Philadelphia DevOps meetup a few years ago<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup> where he called this
idea &quot;coding in production.&quot; The key to making this work is that the
interface should be exploratory, as one gets with a REPL or SQL
console, and that it should be properly constrained for safety.</p>
<p>This all came to mind again recently while working on an application
with a lot of internal state, where I wanted to expose a REPL to
operators so they could debug that state &quot;live&quot;. For various reasons,
I want to be able to assert to the owner of the data that the shell
user can't arbitrarily damage the data<sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup>. So I've built the
beginnings of an embeddable Scheme interpreter in Rust, compiled to a
Web Assembly (WASM) module hosted via Wasmtime.</p>
<p>Most of the use cases I've seen for WASM boil down to either (1) &quot;I
don't want to write JavaScript for the web&quot; or (2) &quot;I want to host
other people's untrusted code in a PaaS-like environment&quot;, which are
both awesome use cases. But this means that a lot of the example code
in the documentation handwaves over the communication between the host
application and the WASM guest, because either you're leaning on DOM
bindgen libraries or exposing a narrow system interface to the guest
like allowing it access to specific file handles. In particular, I
struggled with figuring out how a guest written in Rust was supposed
to set up linear memory and make host function calls.</p>
<p>I've published the code below as a repository with commits for each
step at <a href="https://github.com/tgross/wasm-shell-example">tgross/wasm-shell-example</a>.</p>
<blockquote>
<p>Allergy warning: please note that this use case requires the
<code>unsafe</code> keyword in the guest application. The host application has
no use of <code>unsafe</code> in the application code, but of course if you dig
down far enough into the wasmtime library you'll find it there as
well. In any case, this code was extracted from the project I'm
working on and is intended for educational purposes and not any
particular use.</p>
</blockquote>
<p>Because my Scheme interpreter is incomplete and not the point of this
post, we'll start with the dumbest possible shell that just echos
whatever you input:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">user_input</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="n">io</span>::<span class="n">stdin</span><span class="p">()</span><span class="w">
</span><span class="w">            </span><span class="p">.</span><span class="n">read_line</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">user_input</span><span class="p">)</span><span class="w">
</span><span class="w">            </span><span class="p">.</span><span class="n">expect</span><span class="p">(</span><span class="s">&#34;error reading in user input&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">eval</span><span class="p">(</span><span class="o">&amp;</span><span class="n">user_input</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">eval</span><span class="p">(</span><span class="n">input</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="kt">str</span> <span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">input</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>We'll set up a Cargo workspace with an empty host application, and
exclude the shell from the workspace so that we can compile it to a
separate target via a Makefile<sup id="fnref:4"><a href="#fn:4" class="footnote-ref" role="doc-noteref">4</a></sup>. Then we compile the shell with
<a href="https://github.com/bytecodealliance/cargo-wasi"><code>cargo wasi build</code></a> and get a <code>.wasm</code> target. This is commit <a href="https://github.com/tgross/wasm-shell-example/commit/0e7dff66bf2537f4da0254a7683922a031731cf4"><code>0e7dff6</code></a>.</p>
<p>Next we'll build the host. Most of this is right out of the <a href="https://docs.wasmtime.dev/examples-rust-hello-world.html">Wasmtime
docs on embedding in Rust</a>, but I want to point out that we're using
WASI to let the guest inherit stdin/stdout from the host:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">wasi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">WasiCtxBuilder</span>::<span class="n">new</span><span class="p">().</span><span class="n">inherit_stdio</span><span class="p">().</span><span class="n">build</span><span class="p">();</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Store</span>::<span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">engine</span><span class="p">,</span><span class="w"> </span><span class="n">wasi</span><span class="p">);</span><span class="w">
</span></code></pre></div><p>With <code>cargo run</code> we can interact with the shell directly in our
terminal. This is commit <a href="https://github.com/tgross/wasm-shell-example/commit/c1e34bb804d81932d9e9dc1c92fc360e576362d0"><code>c1e34bb</code></a>, but it's not very interesting.</p>
<p>Instead, let's have the host expose a Unix Domain Socket, and have
each connection on this socket start its own shell. This gives us an
example of how the host program can restrict the guest. We could allow
remote access over TLS with authentication, we could rate-limit
connections or data transfer, or we could allow certain users access
to more WASM &quot;fuel&quot; than others. So long as we implement the
<code>std::io::{Read, Write}</code> traits, the guest shell doesn't need to know
(and indeed <em>shouldn't know</em>) these details.</p>
<p>For each connection, we'll spawn a thread and hand it the new stream
and reference-counted copies of the WASM engine, our compile module,
the linker with our functions (we'll come back to those in a moment),
and the application state:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">linker</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Arc</span>::<span class="n">new</span><span class="p">(</span><span class="n">linker</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Arc</span>::<span class="n">new</span><span class="p">(</span><span class="n">Mutex</span>::<span class="n">new</span><span class="p">(</span><span class="n">State</span>::<span class="n">new</span><span class="p">()));</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">listener</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UnixListener</span>::<span class="n">bind</span><span class="p">(</span><span class="n">bind_path</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">for</span><span class="w"> </span><span class="n">stream</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">listener</span><span class="p">.</span><span class="n">incoming</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">stream</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">stream</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">state</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">engine</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">engine</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">module</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">module</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">linker</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">linker</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span><span class="w">
</span><span class="w">            </span><span class="n">thread</span>::<span class="n">spawn</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">handle_client</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">engine</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">module</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">linker</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">state</span><span class="p">));</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">eprintln</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;connection failed&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">            </span><span class="k">break</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>In the handler, we end up needing to clone the stream twice: once to
split it into a reader and writer stream (for stdin and stdout), and
once more to have an error channel so the host can send in-band error
messages to the client even if the guest shell exits unexpectedly.</p>
<p>Next we present the two streams as <code>WasiFile</code> to the WASI context, and
spawn a new <code>wasmtime::Store</code> from this context and the application
state:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">wasi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">WasiCtxBuilder</span>::<span class="n">new</span><span class="p">()</span><span class="w">
</span><span class="w">    </span><span class="p">.</span><span class="n">stdin</span><span class="p">(</span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">ReadPipe</span>::<span class="n">new</span><span class="p">(</span><span class="n">stream</span><span class="p">))</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">WasiFile</span><span class="o">&gt;</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">.</span><span class="n">stdout</span><span class="p">(</span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">WritePipe</span>::<span class="n">new</span><span class="p">(</span><span class="n">write_stream</span><span class="p">))</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">dyn</span><span class="w"> </span><span class="n">WasiFile</span><span class="o">&gt;</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">.</span><span class="n">build</span><span class="p">();</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Store</span>::<span class="n">new</span><span class="p">(</span><span class="w">
</span><span class="w">    </span><span class="o">&amp;</span><span class="n">engine</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">StoreData</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">state</span>: <span class="nc">state</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">wasi</span>: <span class="nc">wasi</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="p">},</span><span class="w">
</span><span class="w"></span><span class="p">);</span><span class="w">
</span></code></pre></div><p>And finally we instantiate our WASM instance with the shell. Because
we've built a binary (i.e. something with a <code>main</code>), we'll call the
<code>_start</code> function. This is commit <a href="https://github.com/tgross/wasm-shell-example/commit/fafc0f316ad30ef318019b8f7253dd896a920ea4"><code>fafc0f3</code></a>.</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">run_interpreter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">move</span><span class="w"> </span><span class="o">||</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">Trap</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">linker</span><span class="p">.</span><span class="n">instantiate</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">,</span><span class="w"> </span><span class="n">module</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">run</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">instance</span><span class="p">.</span><span class="n">get_typed_func</span>::<span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="p">(),</span><span class="w"> </span><span class="n">_</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;_start&#34;</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="n">run</span><span class="p">.</span><span class="n">call</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">,</span><span class="w"> </span><span class="p">())</span><span class="w">
</span><span class="w"></span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">run_interpreter</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">write</span><span class="o">!</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">err_stream</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">eprintln</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">e</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="k">return</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">};</span><span class="w">
</span></code></pre></div><p>At this point we can <code>cargo run</code> and connect to the socket file from
another terminal with <code>socat - UNIX-CONNECT:/tmp/wasm-shell.sock</code>. But
our shell still doesn't <em>do</em> anything other than echo back our
results. Let's change that.</p>
<h2 id="updating-host-state-from-the-guest">Updating Host State from the Guest</h2>
<p>Earlier we'd glossed over the application state, so let's populate a
<code>State</code> and a separate <code>StoreData</code> that contains the state and the
<code>WasiCtx</code> for the WASM engine. The host application will use this same
object to manipulate state from its side. This could even include a
reference to your database connection if our application had one.</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">struct</span> <span class="nc">State</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">counts</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">StoreData</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">state</span>: <span class="kp">&amp;</span><span class="na">&#39;a</span><span class="w"> </span><span class="n">Arc</span><span class="o">&lt;</span><span class="n">Mutex</span><span class="o">&lt;</span><span class="n">State</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">wasi</span>: <span class="nc">WasiCtx</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>Our state is a vector of integers, and the two functions we're going
to expose to the shell are <code>add</code> to push another number onto the
vector, and <code>sum</code> to total all the numbers we've seen so far. I'm
intentionally punting on more complex objects like strings for the
moment, but we'll come back to that.</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="w"> </span><span class="n">State</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">val</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">counts</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">val</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">sum</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">counts</span><span class="p">.</span><span class="n">iter</span><span class="p">().</span><span class="n">fold</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="k">mut</span><span class="w"> </span><span class="n">sum</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w">
</span><span class="w">            </span><span class="n">sum</span><span class="w">
</span><span class="w">        </span><span class="p">})</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>Wrapping one of these functions has some important details to call
out. The first string is the name of the module our guest will import,
and the second string is the name we'll expose to the guest shell. The
signature of the closure is a <a href="https://docs.rs/wasmtime/0.18.0/wasmtime/struct.Func.html#method.wrap"><code>wasmtime::IntoFunc</code></a> and all the
arguments must be compatible with WebAssembly types. So for example,
you can't pass a <code>usize</code> or <code>u8</code> here, nor can you return a tuple or
struct. When we want to manipulate the state, we call either <code>data()</code>
or <code>data_mut()</code> to get a reference (or mutable reference) to the
caller's <code>Store</code>, and then take the mutex to finally get our <code>State</code>
methods.</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="n">linker</span><span class="p">.</span><span class="n">func_wrap</span><span class="p">(</span><span class="w">
</span><span class="w">    </span><span class="s">&#34;host&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="s">&#34;host_add&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="o">|</span><span class="k">mut</span><span class="w"> </span><span class="n">caller</span>: <span class="nc">Caller</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="p">,</span><span class="w"> </span><span class="n">StoreData</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">param</span>: <span class="kt">i32</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">caller</span><span class="p">.</span><span class="n">data_mut</span><span class="p">().</span><span class="n">state</span><span class="p">.</span><span class="n">lock</span><span class="p">().</span><span class="n">unwrap</span><span class="p">().</span><span class="n">add</span><span class="p">(</span><span class="n">param</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">},</span><span class="w">
</span><span class="w"></span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>How do we call these functions from our shell? The Wasmtime <a href="https://docs.wasmtime.dev/wasm-rust.html#importing-host-functionality">import
host functionality</a> docs are helpful here. Note that calling these
functions is always <code>unsafe</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[link(wasm_import_module = </span><span class="s">&#34;host&#34;</span><span class="cp">)]</span><span class="w">
</span><span class="w"></span><span class="k">extern</span><span class="w"> </span><span class="s">&#34;C&#34;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">host_add</span><span class="p">(</span><span class="n">count</span>: <span class="kt">i32</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">host_sum</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="kt">i32</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>Lastly, we'll update our <code>eval</code> function in the guest to parse our
inputs and call the functions. Normally we'd probably want to use a
real command-line parsing library, but this will do for now.</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">eval</span><span class="p">(</span><span class="n">input</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">String</span> <span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">parsed</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">input</span><span class="p">.</span><span class="n">trim_end</span><span class="p">().</span><span class="n">trim_start</span><span class="p">().</span><span class="n">split</span><span class="p">(</span><span class="sc">&#39; &#39;</span><span class="p">).</span><span class="n">collect</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">parsed</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="nb">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="s">&#34;sum&#34;</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">host_sum</span><span class="p">())</span><span class="w"> </span><span class="p">},</span><span class="w">
</span><span class="w">        </span><span class="nb">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="s">&#34;add&#34;</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">parsed</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="nb">Some</span><span class="p">(</span><span class="n">next</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="kt">str</span>::<span class="n">parse</span><span class="p">(</span><span class="n">next</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="nb">Ok</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">host_add</span><span class="p">(</span><span class="n">i</span><span class="p">);</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">                    </span><span class="s">&#34;ok&#34;</span><span class="p">.</span><span class="n">to_string</span><span class="p">()</span><span class="w">
</span><span class="w">                </span><span class="p">}</span><span class="w">
</span><span class="w">                </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">            </span><span class="p">},</span><span class="w">
</span><span class="w">            </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>At this point we should be able to run the application, and connect
with two different instances of socat. Each connection should be able
to see the changes written to the state by the other, so if we <code>add 2</code>
in one and <code>add 3</code> in the other, <code>sum</code> will now return <code>5</code> in
both. This is commit <a href="https://github.com/tgross/wasm-shell-example/commit/a226910c2201500e4108b7c6fa851eee9ed1f8dc"><code>a226910</code></a>.</p>
<h2 id="working-around-interface-types">Working Around Interface Types</h2>
<p>To use functions that pass arguments or return values that are
something other than integers and floats, we need <a href="https://github.com/webassembly/interface-types">WebAssembly
Interface Types</a>. Unfortunately these have not yet been standardized
and shipped! This would put a damper on our ambitions to have a shell,
but we can work around this by using WASM linear memory.</p>
<p>Effectively what we're going to do is make a syscall-like interface
between our guest and host. The guest will write to a buffer, and then
call a host function passing a pointer (or rather, an offset in the
WASM linear memory) and length for each parameter and for the return
value. The host will get the result and write the value back to return
buffer and return the length of the data written to the caller.</p>
<p>We'll be using &quot;safe&quot; <code>wasmtime::Memory</code> interfaces on the host side
that copy the data out before working on it, and on the guest side
we're single threaded and waiting on the return from the host
function. So we don't need to worry about the guest messing with the
data while we're reading it. (And hopefully interface types ship
before threads!)</p>
<p>That being said, I managed to segfault the guest a few dozen times
before finally finding Radu Matei's excellent <a href="https://radu-matei.com/blog/practical-guide-to-wasm-memory/"><em>Practical Guide to
WASM Memory</em></a>. The control flow we have here is reverse from Matei's
post, because the guest is deciding what to allocate. But as it turns
out this largely gets implemented in the same way. We want these two
functions in the guest:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">alloc</span><span class="p">(</span><span class="n">len</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">u8</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">0</span><span class="k">u8</span><span class="p">;</span><span class="w"> </span><span class="n">len</span><span class="p">];</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buf</span><span class="p">.</span><span class="n">as_mut_ptr</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">std</span>::<span class="n">mem</span>::<span class="n">forget</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">ptr</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">unsafe</span><span class="w"> </span><span class="k">fn</span> <span class="nf">dealloc</span><span class="p">(</span><span class="n">ptr</span>: <span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span><span class="w"> </span><span class="n">len</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">_buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Vec</span>::<span class="n">from_raw_parts</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">len</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">std</span>::<span class="n">mem</span>::<span class="n">drop</span><span class="p">(</span><span class="n">_buf</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>If we were exporting these functions from the guest these would need
to be <code>extern &quot;C&quot;</code>, but in this workflow we'll keep all the <code>unsafe</code>
code inside the guest. When the guest prepares a buffer for the host
(either a parameter or space for the result), it calls <code>alloc</code>. That
<code>alloc</code> function &quot;forgets&quot; about the buffer we allocate without
dropping it. If we skip this, the buffer will get reclaimed and the
host will get garbage data (which it will safely reject when it tries
to parse it into a string). But the error message we write in the
return buffer is also corrupt in the same way, and the guest crashes
(&quot;traps&quot;, in WASM parlance). This workflow also means we need to clean
up the buffer manually with <code>dealloc</code>. In <code>dealloc</code> we read the buffer
pointed to by the pointer, and then drop it.</p>
<p>We can put this all together to pass a string to the <code>host_kv_get</code>
function. We allocate a buffer for the key, and copy the key into
it. We also need to allocate the buffer for the response. Then we pass
the pointers and lengths of both buffers into the <code>host_kv_get</code>
function that we've imported. The return value of <code>host_kv_get</code> will
be the number of bytes written into the response buffer.</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">eval_kv_get</span><span class="p">(</span><span class="n">key</span>: <span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">String</span> <span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">key_len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">key</span><span class="p">.</span><span class="n">len</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">res</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">key_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">alloc</span><span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="n">len</span><span class="p">());</span><span class="w">
</span><span class="w">        </span><span class="n">std</span>::<span class="n">ptr</span>::<span class="n">copy</span><span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="n">as_ptr</span><span class="p">(),</span><span class="w"> </span><span class="n">key_ptr</span><span class="p">,</span><span class="w"> </span><span class="n">key_len</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">res_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">alloc</span><span class="p">(</span><span class="n">MAX_RESPONSE_LENGTH</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">_res_len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">host_kv_get</span><span class="p">(</span><span class="w">
</span><span class="w">            </span><span class="n">key_ptr</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">key_len</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">res_ptr</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">MAX_RESPONSE_LENGTH</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">res_len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_res_len</span><span class="p">.</span><span class="n">try_into</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">read_results</span><span class="p">(</span><span class="n">res_ptr</span><span class="p">,</span><span class="w"> </span><span class="n">res_len</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="c1">// free our forgotten memory for the key; the from_utf8 will
</span><span class="c1"></span><span class="w">        </span><span class="c1">// free the response buffer
</span><span class="c1"></span><span class="w">        </span><span class="n">dealloc</span><span class="p">(</span><span class="n">key_ptr</span><span class="p">,</span><span class="w"> </span><span class="n">key_len</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">std</span>::<span class="kt">str</span>::<span class="n">from_utf8</span><span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">to_string</span><span class="p">(),</span><span class="w">
</span><span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;error parsing results as string: {:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>The <code>eval_key_set</code> function is almost identical, but with an extra
buffer for the value we want to set. The guest side of this work is
commit <a href="https://github.com/tgross/wasm-shell-example/commit/c84c5960726bdaf4e02ae25541d2a33a378adb51"><code>c84c596</code></a>.</p>
<h2 id="reading-memory-from-the-host">Reading Memory From the Host</h2>
<p>As we saw earlier the <a href="https://docs.rs/wasmtime/0.30.0/wasmtime/struct.Func.html#method.wrap"><code>wasmtime::FuncWrap</code></a> expects a closure and if
we want to access memory the first parameter of that closure is a
<a href="https://docs.rs/wasmtime/0.30.0/wasmtime/struct.Caller.html#"><code>wasmtime::Caller</code></a>. Getting the memory and accessing the store in
the correct order is a little fussy if you want to both read and write
to memory in the same function (as we do here), because writing will
need a mutable borrow. I've elided some error handling here but you
can see the full code listing in commit <a href="https://github.com/tgross/wasm-shell-example/commit/f95d3980b7d77a446d1b5c23cf466af33a0792d7"><code>f95d398</code></a>. Note that we're
looking for the export named &quot;memory&quot;, which is what the <code>wasm32-wasi</code>
target <a href="https://docs.wasmtime.dev/wasm-rust.html#exporting-rust-functionality">exports by default</a>.</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="n">linker</span><span class="p">.</span><span class="n">func_wrap</span><span class="p">(</span><span class="w">
</span><span class="w">    </span><span class="s">&#34;host&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;host_kv_get&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="o">|</span><span class="k">mut</span><span class="w"> </span><span class="n">caller</span>: <span class="nc">Caller</span><span class="o">&lt;</span><span class="na">&#39;_</span><span class="p">,</span><span class="w"> </span><span class="n">StoreData</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">     </span><span class="n">key_ptr</span>: <span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">key_len</span>: <span class="kt">u32</span><span class="p">,</span><span class="w">
</span><span class="w">     </span><span class="n">res_ptr</span>: <span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">res_len</span>: <span class="kt">u32</span><span class="o">|</span><span class="w">
</span><span class="w">     </span>-&gt; <span class="kt">u32</span> <span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">mem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">caller</span><span class="p">.</span><span class="n">get_export</span><span class="p">(</span><span class="o">&amp;</span><span class="s">&#34;memory&#34;</span><span class="p">){</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">store</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">caller</span><span class="p">.</span><span class="n">as_context</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kv_get</span><span class="p">(</span><span class="n">mem</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">store</span><span class="p">,</span><span class="w"> </span><span class="n">key_ptr</span><span class="p">,</span><span class="w"> </span><span class="n">key_len</span><span class="p">,</span><span class="w"> </span><span class="n">res_ptr</span><span class="p">,</span><span class="w"> </span><span class="n">res_len</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="c1">// now that we&#39;re done with our borrow, upgrade to mutable
</span><span class="c1"></span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">caller</span><span class="p">.</span><span class="n">as_context_mut</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="nb">Ok</span><span class="p">(</span><span class="n">response</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">write_response</span><span class="p">(</span><span class="n">mem</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">,</span><span class="w"> </span><span class="n">res_ptr</span><span class="p">,</span><span class="w"> </span><span class="n">res_len</span><span class="p">,</span><span class="w"> </span><span class="n">response</span><span class="p">)</span><span class="w">
</span><span class="w">                    </span><span class="p">.</span><span class="n">map_err</span><span class="p">(</span><span class="o">|</span><span class="n">err</span><span class="o">|</span><span class="w"> </span><span class="n">eprintln</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">))</span><span class="w">
</span><span class="w">                    </span><span class="p">.</span><span class="n">unwrap_or</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">            </span><span class="nb">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">},</span><span class="w">
</span><span class="w"></span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>This wrapper is calling into functions that return a <code>Result</code> and then
it's responsible for writing that response back. The <code>kv_get</code>
implementation can be fairly slim:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">kv_get</span><span class="p">(</span><span class="w">
</span><span class="w">    </span><span class="n">mem</span>: <span class="nc">Memory</span><span class="p">,</span><span class="w"> </span><span class="n">store</span>: <span class="kp">&amp;</span><span class="nc">StoreContext</span><span class="o">&lt;</span><span class="n">StoreData</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">key_ptr</span>: <span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">key_len</span>: <span class="kt">u32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">res_ptr</span>: <span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">res_len</span>: <span class="kt">u32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">key</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">read_parameter</span><span class="p">(</span><span class="n">mem</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">store</span><span class="p">,</span><span class="w"> </span><span class="n">key_ptr</span><span class="p">,</span><span class="w"> </span><span class="n">key_len</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="n">validate_wasm_param</span><span class="p">(</span><span class="n">res_ptr</span><span class="p">,</span><span class="w"> </span><span class="n">res_len</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">max_len</span>: <span class="kt">usize</span> <span class="o">=</span><span class="w"> </span><span class="n">res_len</span><span class="p">.</span><span class="n">try_into</span><span class="p">().</span><span class="n">unwrap_or</span><span class="p">(</span><span class="mi">1024</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">store</span><span class="p">.</span><span class="n">data</span><span class="p">().</span><span class="n">state</span><span class="p">.</span><span class="n">lock</span><span class="p">().</span><span class="n">unwrap</span><span class="p">().</span><span class="n">map</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">response</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">map</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">).</span><span class="n">ok_or</span><span class="p">(</span><span class="n">anyhow</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;no such key&#34;</span><span class="p">))</span><span class="o">?</span><span class="p">.</span><span class="n">to_string</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">response</span><span class="p">.</span><span class="n">truncate</span><span class="p">(</span><span class="n">max_len</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">response</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>And finally we have a couple of helper functions for reading and
writing the memory:</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">read_parameter</span><span class="p">(</span><span class="w">
</span><span class="w">    </span><span class="n">mem</span>: <span class="nc">Memory</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">store</span>: <span class="kp">&amp;</span><span class="nc">StoreContext</span><span class="o">&lt;</span><span class="n">StoreData</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">ptr</span>: <span class="kt">u32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">len</span>: <span class="kt">u32</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">validate_wasm_param</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">len</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">0</span><span class="k">u8</span><span class="p">;</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">];</span><span class="w">
</span><span class="w">    </span><span class="n">mem</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">store</span><span class="p">,</span><span class="w"> </span><span class="n">ptr</span><span class="p">.</span><span class="n">try_into</span><span class="p">()</span><span class="o">?</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">buf</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">std</span>::<span class="kt">str</span>::<span class="n">from_utf8</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">)</span><span class="o">?</span><span class="p">.</span><span class="n">to_string</span><span class="p">())</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">write_response</span><span class="p">(</span><span class="w">
</span><span class="w">    </span><span class="n">mem</span>: <span class="nc">Memory</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">store</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">StoreContextMut</span><span class="o">&lt;</span><span class="n">StoreData</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">ptr</span>: <span class="kt">u32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">max_len</span>: <span class="kt">u32</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="k">mut</span><span class="w"> </span><span class="n">response</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">response</span><span class="p">.</span><span class="n">truncate</span><span class="p">(</span><span class="n">max_len</span><span class="p">.</span><span class="n">try_into</span><span class="p">()</span><span class="o">?</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">mem</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">store</span><span class="p">,</span><span class="w"> </span><span class="n">ptr</span><span class="p">.</span><span class="n">try_into</span><span class="p">()</span><span class="o">?</span><span class="p">,</span><span class="w"> </span><span class="n">response</span><span class="p">.</span><span class="n">as_bytes</span><span class="p">())</span><span class="o">?</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">response</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>This is all wired up in commit <a href="https://github.com/tgross/wasm-shell-example/commit/f95d3980b7d77a446d1b5c23cf466af33a0792d7"><code>f95d398</code></a>. Now we can <code>cargo run</code> and
connect to the shell, and do <code>set :key :val</code> in one shell and retrieve
that value from <code>get :key</code> in another shell.</p>
<h2 id="wrapping-up">Wrapping Up</h2>
<p>So how practical is all of this? I haven't yet explored async
functions, which is fine for this use case but could be a performance
issue for guests that are doing a lot of IO. There's definitely enough
to build a real application here. But expect to have to make some
investment in the infrastructure around host/guest communication.</p>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>The command window doubled as an AutoLISP REPL, but you could
of course also load programs from files on disk, including while
starting up AutoCAD. I have a vague memory that the entire drawing
could even be exported as a s-expression in text format, but a
quick look at the DXF format spec says my memory is faulty. Was
there another way to do this that I've forgotten? <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p>Sadly it's not online anywhere. <a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3" role="doc-endnote">
<p>Not the least of which because I'll be the only operator for the
foreseeable future and I'm obviously an idiot. <a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:4" role="doc-endnote">
<p>It looks like
<a href="https://github.com/rust-lang/cargo/issues/9406">cargo/#9406</a> will
make this unnecessary. <a href="#fnref:4" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>

  

</section>
<section class="meta">
  <section class="blocks">
  

  <a class="block" href="https://github.com/tgross" title="Visit my GitHub">
    <span class="ss-social-circle ss-octocat"></span>
    <div>Collaborate.</div>
  </a>

  <a class="block" href="mailto:tim+blog@0x74696d.com" title="Email me">
    <span class="ss-social-circle ss-mail"></span>
    <div>Communicate.</div>
  </a>

  <a class="block" href="/index.xml" rel="alternate" type="application/rss+xml" title="0x74696d RSS">
    <span class="ss-social-circle ss-rss"></span>
    <div>RSS.</div>
  </a>
  </section>

  <div class="disclaimer">
    <p>&copy; Timothy Gross</p>
    <p>Except where otherwise noted, content on this site is licensed under <a href="http://creativecommons.org/licenses/by-sa/3.0/deed.en_US">Creative Common Attribution 3.0 Unported License</a>. The code of this blog and all code content is licensed under the <a href="/LICENSE">MIT license</a>.</p>
  </div>
  <div style="clear: both"></div>

</section>

</body>
</html>
