<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
  <title>0x74696d | A ZFS Driver for Nomad, Part 2</title>
  <meta name="author" content="map[]" />
  <meta name="description" content="T-Minus 15.193792102158E&#43;9 years until the universe closes!" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="alternate" type="application/rss+xml" href="/rss.xml" />
  
  <link rel="stylesheet" href="/css/base.css" type="text/css" media="all" />
  <link rel="stylesheet" href="/fonts/ss-social.css" type="text/css" />

  <link rel="stylesheet" href="/css/pygments.css" type="text/css" />
</head>

<body>
  <div class="header">
    <div class="container">
      <section class="name">
        <a href="/"><b>0x74696d</b></a>
      </section>

      <ul class="menu">
        <li><a href="/">Posts</a></li>
        <li><a href="https://github.com/tgross?tab=repositories">Projects</a></li>
        <li><a href="/community/">Community</a></li>
        
      </ul>

    </div>
  </div>

<section class="container content">
  <h1>A ZFS Driver for Nomad, Part 2</h1>
  <section class="byline">February 15, 2021</section>
  <p>A keen observer will note the title of this series has been
altered. In the previous post I discussed an option to have a device
driver that communicated with the Nomad API. Because device plugins
are launched via
<a href="https://github.com/hashicorp/go-plugin"><code>go-plugin</code></a>, we don't
typically have to worry about securing their communication with
Nomad. But if the plugin were to talk to the Nomad HTTP API, we'd need
to give it ACL tokens and certificates for mTLS. This was going to
introduce a bunch of operational lifecycle complexity I don't want to
deal with.</p>
<p>This design exercise has certainly given me some interesting things to
think about for the future of Nomad's Device Plugin API. But it looks
like the best way to move forward is to implement the ZFS plugin as a
CSI driver. <em>Sigh</em>. Fine. Let's get to it.</p>
<p>If I take a look at the <a href="https://github.com/container-storage-interface">CSI organization on
GitHub</a>, there's a
notable lack of starter projects or examples. That's because the
developer community for CSI is working over in the <a href="https://github.com/kubernetes-csi">Kubernetes
CSI</a> organization. There's not
exactly a skeleton project there either, but we do have the
<a href="https://github.com/kubernetes-csi/drivers">drivers</a> repo which looks
promising at first. That includes a
<a href="https://github.com/kubernetes-csi/drivers/tree/master/pkg/csi-common"><code>csi-common</code></a>
package, but that was last updated 2 years ago. Most of this code
seems to have made its way over to the
<a href="https://github.com/kubernetes-csi/csi-driver-host-path"><code>csi-driver-host-path</code></a>
plugin repo, so that should serve as a good guide for the bits of the
spec that Kubernetes implements. There are also some reasonably solid
<a href="https://kubernetes-csi.github.io/docs/developing.html">developer
docs</a>.</p>
<p>I also did a quick survey of the landscape and found the
<a href="https://github.com/democratic-csi/democratic-csi"><code>democratic-csi</code></a>
project, which aims to be a framework for CSI plugins. But those folks
are writing plugins in NodeJS, so that's not going to help me. But,
hey, it's cool that they at least acknowledge
<a href="https://github.com/democratic-csi/democratic-csi/blob/master/docs/nomad.md">Nomad</a>.</p>
<p>Time to get to coding. I'll start by creating the repo in GitHub <sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>,
including the MPL2 license and a golang <code>.gitignore</code> file. I clone
that down and run <code>go mod init github.com/tgross/zfs-csi-driver</code>. I
know we'll need the protobufs from the CSI spec library, and I know
from having worked on the orchestrator side that this is a gRPC
service, so I'll grab that while I'm at it:</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">require <span class="o">(</span>
        github.com/container-storage-interface/spec v1.3.0
        google.golang.org/grpc v1.35.0
<span class="o">)</span>
</code></pre></div><p>The CSI specification is broken into three gRPC services:
<strong>Identity</strong>, <strong>Node</strong>, and <strong>Controller</strong>. I'll dig into the Node and
Controller services in later posts, but all plugins need to run the
Identity service. Nomad will call the Identity service when the plugin
task starts and for liveness checks, and the plugin responds with
metadata and capabilities.</p>
<p>In CSI the plugin implements the &quot;server&quot; and the orchestrator (Nomad
or Kubernetes) is the client. So I'll start by implementing an empty
<a href="https://github.com/container-storage-interface/spec/blob/v1.3.0/lib/go/csi/csi.pb.go#L5185-L5190"><code>IdentityServer</code>
interface</a>:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">IdentityServer</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">i</span> <span class="o">*</span><span class="nx">IdentityServer</span><span class="p">)</span> <span class="nf">GetPluginInfo</span><span class="p">(</span>
	<span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="o">*</span><span class="nx">csipb</span><span class="p">.</span><span class="nx">GetPluginInfoRequest</span><span class="p">)</span> <span class="p">(</span>
	<span class="o">*</span><span class="nx">csipb</span><span class="p">.</span><span class="nx">GetPluginInfoResponse</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">i</span> <span class="o">*</span><span class="nx">IdentityServer</span><span class="p">)</span> <span class="nf">GetPluginCapabilities</span><span class="p">(</span>
	<span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="o">*</span><span class="nx">csipb</span><span class="p">.</span><span class="nx">GetPluginCapabilitiesRequest</span><span class="p">)</span> <span class="p">(</span>
	<span class="o">*</span><span class="nx">csipb</span><span class="p">.</span><span class="nx">GetPluginCapabilitiesResponse</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">i</span> <span class="o">*</span><span class="nx">IdentityServer</span><span class="p">)</span> <span class="nf">Probe</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="o">*</span><span class="nx">csipb</span><span class="p">.</span><span class="nx">ProbeRequest</span><span class="p">)</span> <span class="p">(</span>
	<span class="o">*</span><span class="nx">csipb</span><span class="p">.</span><span class="nx">ProbeResponse</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p>I'm just dropping all this in <code>main.go</code> for the moment. As the series
goes on I'll factor each of the services out into their own files. For
now I just want to make sure I've got all the dependencies figured
out. I'll instantiate a unix socket listener with some very crude
argument parsing, and wire that up to an out-of-the-box gRPC
server. I'll run that, just making sure it compiles and that it binds
to the socket file. That's <a href="https://github.com/tgross/zfs-csi-driver/commit/31e0be537de241fa1e76c793d016cb4e5afe8d94">31e0be5</a>.</p>
<p>Next I'll take a quick detour to add the binary output to our
gitignore, and whip up a makefile. The <code>build</code> target is simple for
now but I always end up wanting to add a bunch of flags later. And I
add a <code>check</code> target to run some linting and static analysis. That's
<a href="https://github.com/tgross/zfs-csi-driver/commit/722669e67095f8b30bc28af55439a3602e56a048">722669e</a>:</p>
<pre><code>$ make check
gofmt ......... ok!
go vet ........ ok!
staticcheck ... ok!
go mod tidy ... ok!
</code></pre><p>With our <em>mise</em> solidly <em>en place</em>, I'll get the Identity service into
enough shape where I can at least make sure it'll register itself as a
CSI plugin. I'll have both the <a href="https://github.com/container-storage-interface/spec/blob/master/spec.md#identity-service-rpc">Identity service
spec</a>
and the generated <a href="https://pkg.go.dev/github.com/container-storage-interface/spec@v1.3.0/lib/go/csi">library
docs</a>
handy.</p>
<p>First I need to return a
<a href="https://pkg.go.dev/github.com/container-storage-interface/spec@v1.3.0/lib/go/csi#GetPluginInfoResponse"><code>GetPluginInfoResponse</code></a>. I
don't think I have a use for the manifest field, but I'll leave that
commented out here to remind myself later.</p>
<div class="highlight"><pre class="chroma"><code class="language-diff" data-lang="diff"><span class="gi">+const (
</span><span class="gi">+       pluginName    = &#34;zfs.csi.0x74696d.com&#34;
</span><span class="gi">+       pluginVersion = &#34;0.0.1&#34;
</span><span class="gi">+)
</span><span class="gi">+
</span><span class="gi"></span> type IdentityServer struct{}

 func (i *IdentityServer) GetPluginInfo(context.Context, *csipb.GetPluginInfoRequest) (
        *csipb.GetPluginInfoResponse, error) {
<span class="gd">-       return nil, nil
</span><span class="gd"></span><span class="gi">+       return &amp;csipb.GetPluginInfoResponse{
</span><span class="gi">+               Name:          pluginName,
</span><span class="gi">+               VendorVersion: pluginVersion,
</span><span class="gi">+               // Manifest: map[string]string{}, // TODO?
</span><span class="gi">+       }, nil
</span><span class="gi"></span> }
</code></pre></div><p>Next is the
<a href="https://pkg.go.dev/github.com/container-storage-interface/spec@v1.3.0/lib/go/csi#GetPluginCapabilitiesResponse"><code>GetPluginCapabilitiesResponse</code></a>. I'm
expecting that I'll want to implement the optional Controller service
and that I'll want to be able to tell Nomad not to provision onto
particular nodes. So I'll add both those capabilities to the
response. The constuctor for the <code>PluginCapability</code> is pretty gross,
but I've come to expect that from protobuf-generated code.</p>
<div class="highlight"><pre class="chroma"><code class="language-diff" data-lang="diff"> func (i IdentityServer) GetPluginCapabilities(
        context.Context, *csipb.GetPluginCapabilitiesRequest) (
        *csipb.GetPluginCapabilitiesResponse, error) {
<span class="gd">-       return nil, nil
</span><span class="gd"></span><span class="gi">+       return &amp;csipb.GetPluginCapabilitiesResponse{
</span><span class="gi">+               Capabilities: []*csipb.PluginCapability{
</span><span class="gi">+                       {
</span><span class="gi">+                               Type: &amp;csipb.PluginCapability_Service_{
</span><span class="gi">+                                       Service: &amp;csipb.PluginCapability_Service{
</span><span class="gi">+                                               Type: csipb.PluginCapability_Service_CONTROLLER_SERVICE,
</span><span class="gi">+                                       },
</span><span class="gi">+                               },
</span><span class="gi">+                       },
</span><span class="gi">+                       {
</span><span class="gi">+                               Type: &amp;csipb.PluginCapability_Service_{
</span><span class="gi">+                                       Service: &amp;csipb.PluginCapability_Service{
</span><span class="gi">+                                               Type: csipb.PluginCapability_Service_VOLUME_ACCESSIBILITY_CONSTRAINTS,
</span><span class="gi">+                                       },
</span><span class="gi">+                               },
</span><span class="gi">+                       },
</span><span class="gi">+               },
</span><span class="gi">+       }, nil
</span><span class="gi"></span> }
</code></pre></div><p>And lastly is the
<a href="https://pkg.go.dev/github.com/container-storage-interface/spec@v1.3.0/lib/go/csi#ProbeResponse"><code>Probe</code></a>
RPC, which has the dubious distinction of not returning a simple bool
for the <code>Ready</code> field, but wrapping the type in some Google protobuf
library helper. So I had to add that to my imports.</p>
<div class="highlight"><pre class="chroma"><code class="language-diff" data-lang="diff"> func (i *IdentityServer) Probe(context.Context, *csipb.ProbeRequest) (
        *csipb.ProbeResponse, error) {
<span class="gd">-       return nil, nil
</span><span class="gd"></span><span class="gi">+       return &amp;csipb.ProbeResponse{
</span><span class="gi">+               Ready: &amp;pbwrappers.BoolValue{Value: true},
</span><span class="gi">+       }, nil
</span><span class="gi"></span> }
</code></pre></div><p>That's it for now with the Identity service
(<a href="https://github.com/tgross/zfs-csi-driver/commit/27e646eccb4eb63cb3bb148b8db97c1a4fad7589">27e646e</a>). In
a later post I'll have these RPC endpoints fingerprint the plugin
environment to assert plugin health contingent on access to a
particular zpool, and that the plugin has whatever tools or libraries
it needs.</p>
<p>Now to verify this runs on Nomad. Normally for development I'd
probably prefer to run the plugin via the <code>raw_exec</code> or <code>exec</code> driver,
but a CSI plugin needs to be able to run with <code>CAP_SYSADMIN</code> so unless
and until we give the <code>exec</code> driver a much-needed refresh, I'll need
to use the <code>docker</code> or <code>podman</code> driver.</p>
<p>So that I don't have to constantly rebuild the Docker image, I'll
bind-mount the binary into a standard container. My first pass at this
used the <code>busybox</code> base image, but I was getting a perplexing &quot;no such
file or directory&quot;. After burning a few minutes debugging my Docker
mount configuration, I realized why:</p>
<pre><code>$ ldd bin/zfs-csi-driver
        linux-vdso.so.1 (0x00007fff1fc47000)
        libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f7e29b7e000)
        libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f7e2978d000)
        /lib64/ld-linux-x86-64.so.2 (0x00007f7e29d9d000)
</code></pre><p>What gives? Doesn't go build statically-linked binaries? Yes, but if
you include any package that has C bindings, it'll be dynamically
linked by default. This includes <code>os/user</code> and the all-important <code>net</code>
package from the stdlib. So binding only the binary into the container
will only work if the container image includes these libraries. The
busybox base image is all statically linked, so there's no libc or
pthread to use. I could fix this with the <code>netgo</code> build tag <sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup> or
<code>CGO_ENABLED=0</code> but there's a pretty good chance I'll want to link to
libzfs later anyways. Instead I'll swap out for the <code>debian:buster</code>
base image, which has the same libc and other libraries as my
development machine. That's
<a href="https://github.com/tgross/zfs-csi-driver/commit/46daf091a20c2c0eedc2459f3058a579f2a3a48c">46daf09</a>.</p>
<p>I fire up a Nomad dev agent and run the plugin job:</p>
<pre><code>$ nomad plugin status csi-zfs
ID                   = csi-zfs
Provider             = zfs.csi.0x74696d.com
Version              = 0.0.1
Controllers Healthy  = 0
Controllers Expected = 1
Nodes Healthy        = 0
Nodes Expected       = 1

Allocations
No allocations placed
</code></pre><p>The plugin registers, but it's not being marked healthy. We can see
why in the Nomad client logs:</p>
<blockquote>
<p>2021-02-15T15:47:33.838-0500 [WARN] client.csi-zfs: finished client
unary call: grpc.code=Unimplemented duration=512.367µs
grpc.service=csi.v1.Controller grpc.method=ControllerGetCapabilities</p>
<p>2021-02-15T15:47:33.839-0500 [WARN] client.csi-zfs: finished client
unary call: grpc.code=Unimplemented duration=357.548µs
grpc.service=csi.v1.Node grpc.method=NodeGetInfo</p>
</blockquote>
<p>I haven't implemented the Controller and Node services yet! Next time,
I'll talk a bit more about the architecture of a CSI plugin, what
these services do, and hopefully get the plugin into a healthy status.</p>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>Which I always forget proves to be annoying when they use the
default email address for the initial commit, which is currently
my work address. Although I suppose all this code is copyright my
employer anyways. <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p>Passing <code>-tags netgo</code> forces go to use a pure-go implementation
of <code>net</code> that doesn't use <code>getaddrinfo</code> or other libc functions,
but if you're implementing a client rather than a server I'd
recommend against this because it introduces some operational
gotchas with DNS. <a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>

  <div class="share">
  <a href="https://twitter.com/intent/tweet?url=https%3a%2f%2fblog.0x74696d.com%2fposts%2fzfs-driver-for-nomad-part2%2f&via=0x74696d"
     class="ss-twitter"
     title="Tweet about this post"
     ></a>
</div>

</section>
<section class="meta">
  <section class="blocks">
  <a class="block" href="https://twitter.com/intent/follow?screen_name=0x74696d" title="Follow me on Twitter">
    <span class="ss-social-circle ss-twitter"></span>
    <div>Follow</div>
  </a>

  <a class="block" href="https://github.com/tgross" title="Visit my GitHub">
    <span class="ss-social-circle ss-octocat"></span>
    <div>Collaborate.</div>
  </a>

  <a class="block" href="mailto:tim+blog@0x74696d.com" title="Email me">
    <span class="ss-social-circle ss-mail"></span>
    <div>Communicate.</div>
  </a>

  <a class="block" href="/index.xml" rel="alternate" type="application/rss+xml" title="0x74696d RSS">
    <span class="ss-social-circle ss-rss"></span>
    <div>RSS.</div>
  </a>
  </section>

  <div class="disclaimer">
    <p>&copy; Timothy Gross</p>
    <p>Except where otherwise noted, content on this site is licensed under <a href="http://creativecommons.org/licenses/by-sa/3.0/deed.en_US">Creative Common Attribution 3.0 Unported License</a>. The code of this blog and all code content is licensed under the <a href="/LICENSE">MIT license</a>.</p>
  </div>
  <div style="clear: both"></div>

</section>

</body>
</html>
